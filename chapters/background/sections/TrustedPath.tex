\section{Trusted Path}
\label{ch:background:trustedPath}

The term \emph{trusted path} was first used in 1985 in Trusted Computer System Evaluation Criteria\footnote{Frequently refereed to as \emph{Orange Book}.}\cite{orange_book} which is a computer security standards set by the United States Department of Defense (DoD). There, the trusted path denotes a communication channel between a user and what the user intended to communicate with. The trusted path must ensure that an attacker cannot intercept or modify the information. However, over the last decades, the trusted path concept has been refined heavily. For example, IO trusted path is defined as the problem when a user executes IO operations with a trusted application. The problem of the IO trusted path is an open problem since the wide-spread deployment of GUIs. For example, some of the earliest research papers investigate how much users need to trust the desktop environments~\cite{epstein1991trusting} as it handles sensitive login information from the user.
The problem of trusted user input to a remote server through an untrusted host has been studied in a few different contexts. Here we provide a brief background of some of the existing works. A more detailed analysis of such works could be found in Section~\ref{sec:problemStatementProtection}.

\subsection{Transaction confirmation} One common approach is transaction confirmation using a separate trusted device. For example, in the ZTIC system~\cite{weigold2011}, a USB device with a small display and limited user input capabilities are used to confirm transactions such as payments. The USB device shows a summary of the transaction performed on the untrusted host, and the user is expected to review the summary from the USB device display before confirming it. This approach is prone to \emph{user habituation}, i.e., the risk that users confirm transactions without carefully examining them to be able to proceed with their main task, such as completing the payment, similar to systems that rely on security indicators~\cite{schechter2007emperor,197283,41927}. Another limitation of this approach is that it breaks the normal workflow, as the user has to focus his attention on the USB device screen in addition to the user interface of the host. Finally, such trusted devices with displays and input interfaces can be expensive to deploy. 

\subsection{External Device-based Solution} There are several existing solutions that use trusted external trusted devices as an intermediary between the IO devices and the untrusted host. Fidelius~\cite{Fidelius} uses overlay in conjunction with Intel SGX enclaves to project sensitive input data from the user on the screen. Bump in the Ether~\cite{McCPerRei2006} uses a mobile client as a trusted display that connects to the keyboard and relays encrypted keystrokes to the host. FPGA-based overlays~\cite{fpga_overlay} proposal uses an FPGA device between the display and the host to overlay secure information on the screen/ 


\subsection{Trusted hypervisor} Another common approach is secure user input using a trusted hypervisor. Gyrus~\cite{gyrus} and Not-a-Bot (NAB)~\cite{nab}, Aurora~\cite{liang2019establishing} are systems where a trusted hypervisor, or a trusted VM, captures user input events and compares them to the application payload that is sent to the server. SGXIO~\cite{sgxio} assumes a trusted hypervisor through which the user can provide input securely to a protected application implemented as an Intel SGX enclave~\cite{sgx} which in turn can securely communicate with the server. Bastion-SGX~\cite{BASTION-SGX} proposes a trusted hypervisor-based solution to enable Bluetooth-based IO communication.
