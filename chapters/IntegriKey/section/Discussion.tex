\section{Discussion}
\label{sec:discussion_IK}

\myparagraph{Other application domains} In this chapter, we have focused on the web-based configuration of safety-critical devices and payments through online banking and cryptocurrency wallets. However, our approach is not limited to those application domains. Additionally, one could integrate \name with browser-based email clients and social media to certify that the legitimate user is the one who composes the mail/post. This can be achieved by the \device to sign the mail/post and communicated directly to the server. On the receiving side, there can be two distinct scenarios: i) if the receiver has a \device installed on her host, the \device can check for the signature of the mail/post and validate it, ii) if the receiving side does not have a \device, the browser can use an extension to provide a secure indicator indicating that a legitimate \device indeed signed the mail/post.

\myparagraph{Deployment} Assuming a browser that supports the \webusb standard, our solution can be deployed without any changes to the host. The server-side component of our solution introduces small changes to the server. In the case of legacy systems that are difficult to modify, the required server-side functionality could be implemented by a proxy server. \device could be configured to send the user input events to the proxy that could perform the input trace matching before passing the response to the unmodified legacy server. 

\myparagraph{Bluetooth} \webbt~\cite{webbt} is another recent web API standard by Google Chrome that allows a \js code to communicate with devices that are connected to the host. Our approach could be realized using WebBluetooth as well.

\myparagraph{\webusb security} The recent \webusb and \webbt APIs have received some criticism regarding possible security vulnerabilities. We emphasize that in \name, usage of \webusb is not security-critical, but it only enables communication from the \device to the remote server via the unchanged host. If the use of \webusb should be avoided, \name can still be used with a browser plugin or an additional application on the host (that enables communication to the \device).

\myparagraph{Other user input} Our current implementation is limited to keyboard input. To enable usage with various UIs with keyboard only, our tool converts elements, such as drop-down menus, sliders, and radio buttons, to text inputs. To extend our approach to pointer devices, such as the mouse, several aspects, such as mouse sensitivity and acceleration, and behavior of the mouse at the screen border would have to be considered. The fact that such mouse settings are controlled by the host OS would complicate the implementation. We investigated several commercially available PLCs, medical devices, and online wallets and learned that most of them could be configured through the keyboard alone.

\myparagraph{User authentication} An adversary that controls the host is able to eavesdrop on any user authentication credentials, such as passwords, entered into the host. To prevent such credential stealing, the trusted embedded device could be configured to act as an authentication token in addition to its main purpose of input integrity protection. For example, an administrator could configure the device with client certificates that could be used to authenticate the user during the establishment of $TLS_1$ connection to the server without revealing the authentication credentials to the untrusted host.

\myparagraph{Secure autofill mechanism} Besides integrity protection of user-provided input, \device can also be used as a hardware-assisted autofill mechanism, eliminating the need for storing sensitive data such as user credentials, credit card number, etc. on the browser storage on the untrusted host system. The \device can use its internal flash storage to keep a key-value pairing of the identifier of the input fields and the actual data. The autofill operation is performed by the remote server to send the specific identifier of the input fields to the \device over the \tls channel between the \device and the remote server. 

\name autofill has two phases: 
\emph{i) Initialization} where the user provides input data to the web application for the first time. The flow of operation is identical to the standard \name operation described previously. The remote server sends the identifiers of the input fields to the \device. The \device stores the user data on its internal flash storage corresponding to the identifier. \emph{ii) Autofill} phase allows the \device to populate the web forms in the browser from the data that are stored on its flash storage. The remote server achieves this by sending the identifier to the \device over the dedicated \tls channel.

\myparagraph{Automated specifications} Our current implementation of \tool requires that the developers specify the web page specification manually. An interesting direction for future work would be the development of a tool that parses the web page HTML and \js code to generate the specification automatically. 
%Additionally, we plan to add our mined specification to include in the \tool to act as a template.  

\myparagraph{Other channels} In our design, the connection from the trusted embedded device to the server shares the same physical channel as the browser, i.e., the Internet connectivity of the host. However, \tool can be configured in such a way that this channel remains separated physically from the host. This can be achieved, for example, by using a smartphone application in the role of the trusted device. The drawback is increased TCB size.

\myparagraph{Other trust models} We designed our system considering an adversary that can fully compromise the host. An alternative trust model, similar to~\cite{gyrus,nab}, would be one where the host OS trusted, but the browser, or one of its extensions, is compromised. Under such a trust model, the OS could take the role of the trusted embedded device. 


\myparagraph{Legacy PLCs} Although many modern PLCs use web-based configuration interfaces (e.g., Siemens ~\cite{siemens,siemens2}, Schneider~\cite{schneider}), this is not the case for all legacy PLSc. In principle, \name could be used on non-web PLCs as well. In this case, our solution requires a proxy that runs the webserver that connects to the \device.

