%\vspace{-5pt}
\section{Related Work}
\label{sec:relatedWork}

The problem of protecting integrity of user input that is delivered to a remote server via an untrusted host has been studied previously in a few different contexts. Here we review the most related prior works.

\subsection{User Intention Monitoring} 

The first set of related solutions focus on user \emph{intention}. These systems attempt to ensure that the data received by the remote server is constructed as the user intended. 

Gyrus~\cite{gyrus} records user intentions, in the form of text input typed by the user, and later tallies it with the application payload that is sent to the server. On the host, Gyrus assumes an untrusted guest VM (dom-U) that can manipulate user input and a trusted VM (dom-0) that draws a secure overlay and captures the user input. The overlay is application-specific and covers critical input fields such as the website address bar, mail compose window etc. When the application sends a message to the server, dom-0 matches the captured user input data with the application payload. 

Not-A-Bot (NAB)~\cite{nab} attempts to ensure that data received from the host was generated by the user and not by a malicious software. Also NAB relies on a trusted hypervisor that loads a simple \emph{attester} application whose software configuration can be verified through remote attestation. The attester records user input events and provides a signed statement of them to the server. Binder~\cite{binder} is another similar system where a trusted OS correlates outbound network connections with the recorded user inputs events. The main difference between these solutions and our work is that we assume a fully compromised host.


\subsection{Trusted Path Solutions} 

User input integrity has been studies also in the context of hardware-based trusted execution environments (TEEs). The term \emph{trusted path} refers to a secure communication channel between the user and a protected application running on an untrusted platform. 

UTP~\cite{utp} describes a unidirectional trusted path from the user to a remote server using dynamic root of trust based on Intel's TXT technology~\cite{mccune2008flicker}. The system suspends the execution of the OS and loads a minimal protected application for execution. This loading is measured and stored to a TPM and proved to a remote verifier using remote attestation. The protected application creates a secure channel, records user input and sends them securely to the server. The main drawback of this approach is that such minimal protected applications cannot implement complex (web) user interfaces. For example, UTP is limited to VGA-based text UIs to keep the TCB small.

SGXIO~\cite{sgxio} assumes a trusted hypervisor and trusted device drivers and uses them to create a secure channel from the user to an SGX enclave. Intel's Software Guard Extensions (SGX)~\cite{sgx} is a trusted execution environment (TEE) implemented as a specific execution mode in the processor. SGX allows isolated execution of small protected applications (enclaves) and protects their secrets and execution integrity from any untrusted software running on the same platform. The main difference to our work is the need for a trusted hypervisor.

Zhou et al.~\cite{x86} realize a trusted path for TXT-based TEEs, again relying on a small trusted hypervisor. In this solution, also device drivers are included in the TCB. Wimpy kernel~\cite{wimpyKernel} is a small trusted kernel that manages device drivers for secure user input. We, in contrast, assume a completely compromised host.


\subsection{Transaction Confirmation Devices} 

The third set of known solutions use a separate trusted device to confirm user input for transactions like online payments. ZTIC~\cite{weigold2011} is a small USB device with a display and user input capabilities. This device shows a summary of the transaction performed on the untrusted host and the user is expected to review the summary from the USB device display before confirming it. Kiljan et al.~\cite{6978928} propose a similar transaction confirmation device. 

Such solutions have three main drawbacks. First, they are prone to user habituation, i.e., the user will not always carefully review the transaction. Second, they break the normal workflow, as the user has to focus his attention to the USB device screen in addition to the normal UI on the host. Third, such devices can be expensive to deploy. Our solution is cheap to deploy and the user experience remains mostly unchanged. 

