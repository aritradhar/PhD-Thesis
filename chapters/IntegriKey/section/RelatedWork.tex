\section{Related Work}
\label{sec:relatedWork_IK}

The problem of protecting the integrity of user input that is delivered to a remote server via an untrusted host has been studied previously in a few different contexts. Here we review the most related prior works.

\subsection{Transaction Confirmation Devices} 

The third set of known solutions use a separate trusted device to confirm user input for transactions like online payments. ZTIC~\cite{weigold2011} is a small USB device with a display and user input capabilities. This device shows a summary of the transaction performed on the untrusted host, and the user is expected to review the summary from the USB device display before confirming it. Kiljan et al.~\cite{6978928} propose a similar transaction confirmation device. 

Such solutions have three main drawbacks. First, they are prone to user habituation, i.e., the user will not always carefully review the transaction. Second, they break the normal workflow, as the user has to focus his attention on the USB device screen in addition to the normal UI on the host. Third, such devices can be expensive to deploy. Our solution is cheap to deploy, and the user experience remains mostly unchanged. 



\subsection{User Intention Monitoring} 

The first set of related solutions focus on user \emph{intention}. These systems attempt to ensure that the data received by the remote server is constructed as the user intended. 

Gyrus~\cite{gyrus} records user intentions in the form of text input typed by the user and later tallies it with the application payload that is sent to the server. On the host, Gyrus assumes an untrusted guest VM (dom-U) that can manipulate user input and a trusted VM (dom-0) that draws a secure overlay and captures the user input. The overlay is application-specific and covers critical input fields such as the website address bar, mail compose window, etc. When the application sends a message to the server, dom-0 matches the captured user input data with the application payload. 

Not-A-Bot (NAB)~\cite{nab} attempts to ensure that data received from the host was generated by the user and not by malicious software. Also, NAB relies on a trusted hypervisor that loads a simple \emph{attester} application whose software configuration can be verified through remote attestation. The attester records user input events and provides a signed statement of them to the server. Binder~\cite{binder} is another similar system where a trusted OS correlates outbound network connections with the recorded user inputs events. The main difference between these solutions and our work is that we assume a fully compromised host.


\subsection{TEE-based Solutions} 

User input integrity has also been studied in the context of hardware-based trusted execution environments (TEEs).  UTP~\cite{filyanov2011uni} describes a unidirectional trusted path from the user to a remote server using the dynamic root of trust based on Intel's TXT technology~\cite{mccune2008flicker}. The system suspends the execution of the OS and loads a minimal protected application for execution. This loading is measured and stored to a TPM and proved to a remote verifier using remote attestation. The protected application creates a secure channel, records user input, and sends them securely to the server. The main drawback of this approach is that such minimal protected applications cannot implement complex (web) user interfaces. For example, UTP is limited to VGA-based text UIs to keep the TCB small.

SGXIO~\cite{weiser2017sgxio} assumes a trusted hypervisor and trusted device drivers and uses them to create a secure channel from the user to an SGX enclave. Intel's Software Guard Extensions (SGX)~\cite{sgx} is a trusted execution environment (TEE) implemented as a specific execution mode in the processor. SGX allows isolated execution of small protected applications (enclaves) and protects their secrets and execution integrity from any untrusted software running on the same platform. The main difference to our work is the need for a trusted hypervisor.

Zhou et al.~\cite{zhou2012building} realize a trusted path for TXT-based TEEs, again relying on a small trusted hypervisor. In this solution, also device drivers are included in the TCB. Wimpy kernel~\cite{wimpyKernel} is a small trusted kernel that manages device drivers for secure user input. We, in contrast, assume a completely compromised host.


