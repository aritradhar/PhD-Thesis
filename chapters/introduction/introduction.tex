Interaction between human and software systems is an important aspect of modern computing platforms in terms of providing inputs to them, and interpret the output of a computation. Over the last half a century, researchers in academia and industry spent a significant effort to make this interaction as effortless as possible. IO peripherals and complex user interfaces (UI) are the keys to felicitate this interaction between the user and the end-systems. User interaction through such intuitive UIs was quintessential to the wide-spread deployment of computing devices around us and rapid adoption of remote applications and services. 

Security and safety-critical remote applications such as e-voting, online banking, industrial control systems (such as remote PLCs~\cite{controlbyweb}) and medical devices~\cite{medicalDevice} rely upon user interaction that is typically performed through a \emph{host} system that generally is a standard PC (specifically $x86$ architecture), which gives the host access to the raw IO data that is exchanged between the user and the remote server. The host consists of large and complex system software such as the operating system, device drivers, applications such as a browser, and a diverse set of hardware components that expose the host to a large attack surface. Due to cost and convenience, general-purpose PCs are prevalent in many safety-critical application domains such as industrial plants and hospitals. For example, the WannaCry ransomware incident showed that NHS hospitals relied on Windows XP platforms~\cite{berry_2017,field_wannacry_2018}. 

%In all of these systems, the UI remains one of the essential parts, and the security of such systems is crucial as the codebases of OS, browser, firmware are span over millions of LoC. Such interactions become more complicated when one brings secure computation technologies into the mix. Trusted Execution Environment or TEE is one of the cornerstones of secure, isolated computation against attacker-controlled OS. However, the security guarantees of TEEs are confined only to the applications running on the CPU cores, leaving the external IO peripherals completely insecure. Moreover, the cost of adding such devices into the TEE often results in expanding the trusted computing base (TCB) beyond a reasonable size.

\emph{Trusted path} provides a secure channel between the user (specifically through the human interface devices - HIDs) and the end-point, which is typically a trustworthy application running on the host. A trusted path ensures that user inputs reach the intended application unmodified, and all the outputs presented to the user are generated by the legitimate application. Trusted path can also be extended to general peripherals such as GPU, sensors, etc. Moreover, the trusted path is not only restricted to the interaction between the peripherals and the local host, but could be extended to a remote system. Hence, the remote trusted path to such remote systems is critical in the presence of an attacker that controls the user's computer. Such an attacker can observe and modify any user interaction data without being detected by the user or the server. The trusted path to the local host is a well-researched area where many solutions focus on using trusted software components such as a trusted hypervisor. Zhou et al.~\cite{zhou2012building} proposed a generic trusted path on $x86$ systems with a pure hypervisor-based design. SGXIO~\cite{weiser2017sgxio} employs both a hypervisor and a trusted execution environment (Intel SGX). However, hypervisors are hard to deploy, have a large TCB, and are impractical in real-world scenarios as most of the existing verified hypervisors offer a minimal set of features.


Trusted external devices are another way to realize secure IO between a user and a remote server. Transaction confirmation devices~\cite{filyanov2011uni,weigold2011secure} allow the user to review her input data on a trusted device that is physically separated from the untrusted host. These approaches suffer from poor usability, security issues due to user habituation and are only limited to simple inputs. Proposals such as bump in the Ether~\cite{McCPerRei2006}, MP-Auth~\cite{mannan2007using} use external embedded devices to sign input parameters. However, such solutions do not support output integrity; hence, the attacker can execute UI manipulation attacks to trick the user into providing incorrect inputs. Fidelius~\cite{Fidelius} combines the previous ideas of Bump in the Ether and trusted overlay to protect keyboard inputs from a compromised browser using external devices and a JavaScript interpreter that runs inside an SGX enclave. Fidelius maintains overlays on display, specifically on the input text boxes, to hide sensitive user inputs from the browser. We investigate the security of Fidelius and discover several issues. Fidelius imposes a high cognitive load on the users. The users need to continuously monitor different security indicators (two LED lights and the status bar on the screen) to guarantee the input's integrity and confidentiality. Furthermore, the attacker can manipulate labels of the UI elements to trick the user into providing incorrect input. 
The lack of mouse support, which may appear only as a functional limitation, exposes Fidelius to early form submission attacks. The host can emulate a mouse click on the submit button before the user completes all fields of a form. This allows the attacker to perform an early form submission with incomplete input - a violation of input integrity. 

Trusted execution environments (TEEs) drastically reduce the trusted computing base (TCB) and provide security to applications, known as enclaves, without having to trust the operating system and hypervisor~\cite{costan2016intel,winter2008trusted,costan2016sanctum}. Thus, the attack surface is reduced by eliminating two of the largest sources of vulnerabilities for a system~\cite{checkoway2013iago,suzaki2011memory}. TEEs use isolation primitives provided by the CPU to exclude all software but a single target application from the trusted computing base (TCB). To achieve this trust model, only the CPU is considered trusted, while all the other hardware in the system is explicitly assumed malicious. Even memory is not included in the TCB, and can only be used in conjunction with memory encryption and integrity protection. Such a trust model makes the TEEs ideal candidates for secure interactions with the user. 


While SGX's remote attestation guarantees that the attested enclave runs the expected code, it \emph{does not}, however,  guarantee that the enclave runs on the expected computing platform. An adversary that controls the OS (or other software) on the target platform can relay incoming attestation requests to another platform. This way, the user ends up attesting to the attacker's platform rather than her own. Such also enable the attacker to see all the IO data to and from the user, e.g., sensitive user input on display. Such relay attacks are a long-standing open problem in trusted computing, as already a decade ago, Parno identified such attacks in the context of TPM attestation~\cite{parno2008bootstrapping}. Hence, directly incorporating a trusted path to a TEE like Intel SGX is not a trivial issue.



Apart from the relay attack, TEEs' potential use cases are also limited.  TEEs cannot communicate with any external device without going through the malicious operating system. Various applications ranging from trusted path~\cite{zhou2012building,Fidelius,protection} to data center accelerators~\cite{volos2018graviton} are excluded from the TEE ecosystem. Any such application with high-security requirements is usually solved by one of three approaches: i) a fully dedicated system, ii) a dedicated virtual machine (with trust in the hypervisor), or iii) blind trust in the operating system. We believe none of these approaches to be satisfactory due to either cost (i) or the need to trust codebases (ii \& iii) with millions of lines of code~\cite{torvalds2020linux,barham2003xen}.
The static system architecture of TEEs limits their potential applications to trusted computing use cases, where a user possesses some secret data and wants to outsource the computation to a remote system. Many TEEs actually rely on some external peripherals already, e.g., Intel SGX and the monotonic counters in the management engine~\cite{matetic2017rote} or various academic proposals for trusted path using ARM TrustZone~\cite{SeCloak,VButton}. However, all of these systems are custom-tailored for a single use case and do not allow for any flexibility as they must be configured statically at boot time.


In this dissertation,a we address the three following research questions concerning the trusted path and trusted execution in modern platforms 
\begin{enumerate}
  
  	\item[\textbf{Q1}] How to build a trusted path systems that provide integrity (and possibly confidentiality) guarantees without the users rely on the cognitive-heavy solutions such as transaction confirmation devices while maintaining a small TCB? Are these systems truly secure?
  	
    \item[\textbf{Q2}] Why existing solutions failed to provide a trusted path that provides integrity and confidentiality guarantees to the user interactions? What are the necessary steps in order to build one?
    
    \item[\textbf{Q3}] Relay attack from a local platform to a remote attacker-controlled platform is a real threat to the remote attestation of TEEs like Intel SGX. How to ensure that the attacker cannot relay the attestation to an attacker-controlled platform that exposes all the sensitive IO data?
    
    \item[\textbf{Q4}] How to extend the trusted path mechanism to a modern platform that is interconnected with a number of heterogeneous peripheral devices? How to extend this trusted path into other complex hardware devices such as GPU or accelerator that can execute programs outside the CPU cores? How to make sure the platform-wide integrity guarantee (configuration and interaction of the TEE enclaves and external peripherals) is preserved without relying on a purpose-built system?  
\end{enumerate}

 We propose two systems: \integrikey~\cite{integrikey} and \integriscreen~\cite{integriscreen} to answer \textbf{Q1}, the first research question. \integrikey uses input signing to provide a second factor for the integrity of the keyboard input. While the latter uses a phone camera to capture the information that the user is typing on the screen to provide a second factor for user intention's integrity. Unlike exiting trusted path solutions, these proposals rely neither on any transaction confirmation devices that put a heavy cognitive load on the user nor on a hypervisor or trusted drivers that introduce a large TCB. Moreover, \integriscreen provides a restricted form of output integrity to ensure that the attacker-controlled host does not manipulate UIs. \integrikey uses a small embedded trusted device that runs a few hundred LoC to sign user input. In \integrikey, we identify a new form of input manipulation attack that we name field swapping attack. In a swapping attack, the attacker can swap the levels of different input fields that accept overlapping values (e.g., blood pressure and heart rate for a pacemaker). \integrikey analyzes the type of input fields, and based on the regular expression of these fields; it can compute the overlapping fields that could be vulnerable to swapping attack and recommend the user to append a label with the input value to distinguish it. 
In comparison, the \integriscreen uses a phone to verify the user input by using text recognition and send that result to the server on a different communication channel. Even though both \integrikey and \integriscreen provide a significant improvement over state-of-the-art trusted path solutions, they suffer similar security and functionality pitfalls as their counterparts. They are all ad-hoc approaches focus on solving a single problem and a single input source. This leads to multiple sophisticated attacks on them.

The shortcomings of the existing literature provide the groundwork of our system named \protection that answers the first research question \textbf{Q2}.
\protection is built on the following observations: i) input integrity is possible only when both input and output integrity are ensured simultaneously, ii) all the input modalities are needed to be protected as they influence each other, and iii) high cognitive load results in user habituation errors. \protection uses a trusted low-TCB auxiliary device that we call \deviceprotection, which works as a mediator between all user IO devices and the untrusted host. Instead of implementing a separate network interface, the \deviceprotection uses the host as an untrusted transport - reducing the attack surface. \protection ensures output integrity and confidentiality by sending an encoded UI to the host that only the \deviceprotection can overlay on the part of the screen. The overlay is possible as the \deviceprotection intercepts the display signal between the host and the monitor. The overlay generated by the \deviceprotection ensures that the host cannot manipulate any output information on that overlaid part of the screen; hence, it can not trick the user. All the user interaction to this protected overlay is encrypted and signed by the \deviceprotection. Hence input integrity and confidentiality are preserved.

Parno~\cite{parno2008bootstrapping} identified distance bounding as a candidate solution to TPM relay attacks already ten years ago, but concluded that it could not be realized securely as the slow TPM identification operations (signatures) make a local and relayed attestation indistinguishable. However, the implication if the relay attack was never well-studied. In this dissertation, we investigate the implication of the relay attack and show that it could have an adverse consequence. To answer the second research question, \textbf{Q3},  We propose a new solution, called \proximitee, that prevents relay attacks by leveraging a simple embedded device that we call \deviceproximitee that is attached to the attested target platform. The \deviceproximitee executes a challenge-response protocol between itself and the platform, and based on the latency of the protocol, the \deviceproximitee determines if it is connected to the target platform physically or not. Our solution is best suited to scenarios where i) the deployment cost of such an embedded device is minor compared to the benefit of more secure attestation, and ii) TOFU solutions are not acceptable. Attestation of servers at cloud computing platforms and setup of SGX-based permissioned blockchains are two such examples. 

Finally, to answer \textbf{Q4}, the last research question, We propose a TEE with a \emph{configurable} software and hardware TCB including arbitrary external peripheral devices, a concept that we name \emph{platform isolation environment} (\pie). \pie executes applications in \emph{platform-wide enclaves}, which are analogous to the enclaves provided by TEEs, except that they span several hardware components. For example, a \nameenclave{} can be composed of a output device such as a display, input devices such as keyboard and mouse, the CPU that is executing the program, the GPU that renders the graphics, and the custom code running on them. Like in traditional enclaves, a \nameenclave{} can be remotely attested. However, the \pie attestation not only reports a measurement of the software TCB but also of the hardware components that are part of the \nameenclave{}.

The shift towards configurable hardware and software TCBs has wide-ranging implications concerning integrity, confidentiality, and attestation of a \nameenclave{}. 
Attestation, for one, should cover all individual components of a \nameenclave{} atomically to defend against an attacker that changes the configuration in between attestations to separate components. 
Moreover, the untrusted OS may remap the peripheral devices at runtime with an untrustworthy device, which should not receive access to sensitive data. We carefully design \pie to not be vulnerable to such attacks and present an in-depth security analysis.

We mitigate the above-mentioned attacks with two new properties of \nameenclave{}s: \emph{platform-wide attestation} and \emph{platform awareness}. Platform-wide attestation expands the attestation to cover all components within a \nameenclave, and platform awareness enables enclaves to react to changes in their ecosystem, i.e., remapping by the OS.
We achieve this by introducing two new events into the enclave lifecycle, \textit{connect} and \textit{disconnect}, which allow to track the liveliness of one enclave from another.


\begin{figure}[t]
  \centering
    \includegraphics[trim={0 12cm 11cm 0},clip,width=\linewidth]{chapters/introduction/images/works.pdf}
    \caption[Summary of the works in this thesis]{\textbf{Summary of the works in this thesis.} In this figure, we summarize the works that are in the thesis in a context of a modern computing platform. \one represents the works that are focused to secure the trusted path applications: \integrikey, \integriscreen, and \protection, \two represents \proximitee that brings additional security property to the physical communication link between the peripheral and the trusted path application. Finally, \three represents \pie that takes the platform as a whole: application, driver running on the CPU cores, and firmware running on the peripheral.}
    \label{fig:works}
\end{figure}

In summary, Figure~\ref{fig:works} provides a overview of all the works included in this thesis.


\section{Thesis contribution} 

The contributions of this thesis is divided into four parts as the following:

\begin{enumerate}
  \item \textbf{\integrikey, an ad-hoc approaches to provide second factor for integrity in user input}
\begin{itemize}
    \item \emph{New attack.} In \integrikey, we identify swapping attacks as a novel form of user input manipulation against simple user input matching strategies.
    \item \integrikey. We design and implement a user input integrity protection system that is tailored for keyboard input, prevents swapping attacks, and is easy to deploy.
    \item \integrikey{} tool. We develop a user interface analysis and webpage annotation tool that helps developers to protect their web services and minimizes user effort.
    \item \emph{Evaluation.} We verified that our tool can process UIs of existing safety-critical systems and cryptocurrency wallets correctly. Our experiments show that the performance delay of \integrikey user input integrity protection is low. Our preliminary user study indicates that user input labeling prevents swapping attacks in most cases.
   %, and our preliminary user study indicates that user can perform the needed labeling.
\end{itemize}



    \item \textbf{\protection: Understanding trusted path and building secure trusted path systems}
    \begin{enumerate}
        \item  \textbf{Identification of IO security requirements:} We identify new requirements for trusted path based on the drawbacks of the existing literature: i) unless both output and input integrity are secured simultaneously, it is impossible to achieve any of the two, and ii) without protecting the integrity of all the modalities of inputs, none could be achieved.
        
        \item \textbf{System for IO integrity:} We describe the design of \protection, a system that provides a remote trusted path from the server to the user, in an attacker-controlled environment. The design of \protection leverages a small, low-TCB auxiliary device that acts as a \emph{root-of-trust} for the IO. \protection ensures the integrity of the UI, specifically the integrity of mouse pointer and keyboard input. \protection is further designed to avoid user habituation.
        
        \item \textbf{System for IO confidentiality:} We also describe an extension of \protection that provides IO confidentiality, where user needs to execute an operation like a secure attention sequence (SAS) to identify the trusted overlay on the display.
        
        \item \textbf{Implementation and evaluation:} We also implement a prototype of \protection and evaluate its performance ).
    \end{enumerate}
    
    \item \textbf{\proximitee: Understanding Relay attacks on in Intel SGX remote attestation and building system for addressing the relay attacks in different attacker models (non-emulating vs emulating attacker)}
    
    \begin{enumerate}
        \item \textbf{Analysis of relay attacks.} While relay attacks have been known for more than a decade, their implications have not been fully analyzed. We provide the first such analysis and show how relaying amplifies the adversary's capabilities for attacking SGX enclaves.   

        \item \textbf{\proximitee, a system for addressing relay attacks.} We propose a hardened SGX attestation mechanism based on an embedded device and proximity verification to prevent relay attacks. \proximitee does not rely on the common TOFU assumption, and hence, our solution improves the security of previous attestation approaches. Note that the distance bounding approaches are well-known in the literature, but using such method in the context of SGX is non-trivial.
    
        \item \textbf{Experimental evaluation.} We implement a complete prototype of \proximitee and evaluate it against a very strong and fast adversary. Our evaluation is the first to show that proximity verification can be both secure and reliable for TEEs like SGX.
    
        \item \textbf{Addressing emulation attacks.} We also propose another attestation mechanism based on boot-time initialization to prevent emulation attacks. This mechanism is a novel variant of TOFU with deployment, security and revocation benefits.
    \end{enumerate}
    
    \item \textbf{\pie: Generalizing platform security in the context of TEEs and peripherals}
    
    \begin{enumerate}
        \item \textbf{Security properties for platform-wide integrity} We extend traditional TEEs by introducing a dynamic hardware TCB. We call these new systems platform isolation environment (\pie{}). We identify key security properties for \pie{}, namely \emph{platform-wide attestation} and \emph{platform awareness}.
        
        \item \textbf{Programming model} We propose a programming model that provides the flexibility to the developers is comparable to the modern operating systems for developing enclaves that communicate with peripherals. The programming model abstracts the underlying hardware layer. 
        
        \item \textbf{Prototype and experimental evaluation} We demonstrate a prototype of a \pie{} based on Keystone~\cite{keystone} on an open-source RISC-V processor~\cite{ariane}. The prototype includes a simplified model of the entire platform, including external peripherals emulated by multiple Arduino microcontrollers. In total, our modifications to the software TCB of Keystone only amount to around 350 LoC.

    \end{enumerate}

\end{enumerate}

\section{Thesis Organization}

\section{Publication}

Parts of this thesis are based on the following articles I have co-authored.

\begin{itemize}
  
  \item \textbf{Aritra Dhar}, Enis Ulqinaku,Kari Kostiainen, and Srdjan Capkun, ProtectIOn: Root-of-Trust for IO in Compromised Platforms, \emph{In Proceedings of the 27th Annual Network and Distributed System Security Symposium, NDSS 2020}. 
  
  \item \textbf{Aritra Dhar}, Ivan Puddu, Kari Kostiainen, and Srdjan Capkun, ProximiTEE: Hardened SGX Attestation by Proximity Verification , \emph{In Proceedings of the Tenth ACM Conference on Data and Application Security and Privacy (CODASPY '20)}.
  
  \item Moritz Schneider*, \textbf{Aritra Dhar}*, Ivan Puddu, Kari Kostiainen, and Srdjan Capkun, PIE: A Dynamic TCB for Remote Systems with a Platform Isolation Environment, \emph{arXiv preprint /2010.10416 (2020)}.
  
  \item Kari Kostiainen, \textbf{Aritra Dhar}, and Srdjan Capkun, Dedicated Security Chips in the Age of Secure Enclaves, in \emph{IEEE Security \& Privacy, vol. 18, no. 5, pp. 38-46, Sept.-Oct. 2020}.
  
  \item Ivo Sluganovic, Enis Ulqinaku, \textbf{Aritra Dhar}, Daniele Lain, Srdjan Capkun, and Ivan Martinovic, IntegriScreen: Visually Supervising Remote User Interactions on Compromised Clients, \emph{arXiv preprint 2011.13979 (2020)}.
   
  \item \textbf{Aritra Dhar}, Der-Yeuan Yu, Kari Kostiainen, and Srdjan Capkun, IntegriKey: End-to-End Integrity Protection of User Input, \emph{IACR Cryptology ePrint Archive 2017: 1245 (2017)}.
 
\end{itemize}

 In addition, during my Ph.D., I co-authored the following publications.
 
 \begin{itemize}
   \item Vasilios Mavroudis, Karl Wust, \textbf{Aritra Dhar}, and Kari Kostiainen, Srdjan Capkun:, Snappy: Fast On-chain Payments with Practical Collaterals, \emph{In Proceedings of the 27th Annual Network and Distributed System Security Symposium, NDSS 2020}. 
   \item David M. Sommer, \textbf{Aritra Dhar}, Luka Malisa, Esfandiar Mohammadi, Daniel Ronzani, and Srdjan Capkun, Deniable Upload and Download via Passive Participation, \emph{In Proceedings of the 16th USENIX Symposium on Networked Systems Design and Implementation, NSDI 2019}.
   \item Sinisa Matetic, Mansoor Ahmed, Kari Kostiainen, \textbf{Aritra Dhar}, David M. Sommer, Arthur Gervais, Ari Juels, and Srdjan Capkun, ROTE: Rollback Protection for Trusted Execution, \emph{In Proceeedings of the USENIX Security Symposium 2017}.
 \end{itemize}