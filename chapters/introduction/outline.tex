\section{Thesis Outline}

Security and safety-critical remote applications such as e-voting, online banking, industrial control systems (such as remote PLCs~\cite{controlbyweb}) and medical devices~\cite{medicalDevice} rely upon user interaction that is typically performed through a \emph{host} system that generally is a standard PC (specifically $x86$ architecture), which gives the host access to the raw IO data that is exchanged between the user and the remote server. The host consists of large and complex system software such as the operating system, device drivers, applications such as a browser, and a diverse set of hardware components that expose the host to a large attack surface. Due to cost and convenience, general-purpose PCs are prevalent in many safety-critical application domains such as industrial plants and hospitals. For example, the WannaCry ransomware incident showed that NHS hospitals relied on Windows XP platforms~\cite{berry_2017,field_wannacry_2018}. 


\emph{Trusted path} provides a secure channel between the user (specifically through the human interface devices - HIDs) and the end-point, which is typically a trustworthy application running on the host. A trusted path ensures that user inputs reach the intended application unmodified, and all the outputs presented to the user are generated by the legitimate application. Trusted path can also be extended to general peripherals such as GPU, sensors, etc. Moreover, the trusted path is not only restricted to the interaction between the peripherals and the local host, but could be extended to a remote system. Hence, the remote trusted path to such remote systems is critical in the presence of an attacker that controls the user's computer. Such an attacker can observe and modify any user interaction data without being detected by the user or the server. The trusted path to the local host is a well-researched area where many solutions focus on using trusted software components such as a trusted hypervisor. Zhou et al.~\cite{zhou2012building} proposed a generic trusted path on $x86$ systems with a pure hypervisor-based design. SGXIO~\cite{weiser2017sgxio} employs both a hypervisor and a trusted execution environment (Intel SGX). However, hypervisors are hard to deploy, have a large TCB, and are impractical in real-world scenarios as most of the existing verified hypervisors offer a minimal set of features.  


Trusted external devices are another way to realize secure IO between a user and a remote server. Transaction confirmation devices~\cite{filyanov2011uni,weigold2011secure} allow the user to review her input data on a trusted device that is physically separated from the untrusted host. These approaches suffer from poor usability, security issues due to user habituation and are only limited to simple inputs. Bump in the Ether~\cite{McCPerRei2006} and IntegriKey~\cite{IntegriKey} use external embedded devices to sign input parameters. However, such solutions do not support output integrity; hence, the attacker can execute UI manipulation attacks to trick the user into providing incorrect inputs. Fidelius~\cite{Fidelius} combines the previous ideas of Bump in the Ether and trusted overlay to protect keyboard inputs from a compromised browser using external devices and a JavaScript interpreter that runs inside an SGX enclave. Fidelius maintains overlays on display, specifically on the input text boxes, to hide sensitive user inputs from the browser. We investigate the security of Fidelius and discover several issues. Fidelius imposes a high cognitive load to the users as they need to monitor continuously different security indicators (two LED lights and the status bar on the screen) to guarantee the integrity and confidentiality of the input. Furthermore, the attacker can manipulate labels of the UI elements to trick the user into providing incorrect input. 
The lack of mouse support, which may appear only as a functional limitation, exposes Fidelius to early form submission attacks. The host can emulate a mouse click on the submit button before the user completes all fields of a form. This allows the attacker to perform an early form submission with incomplete input - a violation of input integrity. 

Trusted execution environments (TEEs) drastically reduce the trusted computing base (TCB) and provide security to applications, known as enclaves, without having to trust the operating system and hypervisor~\cite{costan2016intel,winter2008trusted,costan2016sanctum}. Thus, the attack surface is reduced by eliminating two of the largest sources of vulnerabilities for a system~\cite{checkoway2013iago,suzaki2011memory}. TEEs make use of isolation primitives provided by the CPU to exclude all software but a single target application from the trusted computing base (TCB). To achieve this trust model, only the CPU is considered trusted, while all the other hardware in the system is explicitly assumed malicious. Even memory is not included in the TCB, and can only be used in conjunction with memory encryption and integrity protection. Such a trust model makes the TEEs ideal candidates for secure interactions with the user. 


While SGX's remote attestation guarantees that the attested enclave runs the expected code, it \emph{does not}, however,  guarantee that the enclave runs on the expected computing platform. An adversary that controls the OS (or other software) on the target platform can relay incoming attestation requests to another platform. This way, the user ends up attesting the attacker's platform rather than her own. Such also enable the attacker to see all the IO data to and from the user, e.g., sensitive user input on display. Such relay attacks are a long-standing open problem in trusted computing, as already a decade ago, Parno identified such attacks in the context of TPM attestation~\cite{parno2008bootstrapping}. Hence, directly incorporating a trusted path to a TEE like Intel SGX is not a trivial issue.



Apart from the relay attack, TEEs' potential use cases are also limited.  TEEs cannot communicate with any external device without going through the malicious operating system. Various applications ranging from trusted path~\cite{zhou2012building,Fidelius,protection} to data center accelerators~\cite{volos2018graviton} are excluded from the TEE ecosystem. Any such application with high-security requirements is usually solved by one of three approaches: i) a fully dedicated system, ii) a dedicated virtual machine (with trust in the hypervisor), or iii) blind trust in the operating system. We believe none of these approaches to be satisfactory due to either cost (i) or the need to trust codebases (ii \& iii) with millions of lines of code~\cite{torvalds2020linux,barham2003xen}.
The static system architecture of TEEs limits their potential applications to trusted computing use cases, where a user possesses some secret data and wants to outsource the computation to a remote system. Many TEEs actually rely on some external peripherals already, e.g., Intel SGX and the monotonic counters in the management engine~\cite{matetic2017rote} or various academic proposals for trusted path using ARM TrustZone~\cite{SeCloak,VButton}. However, all of these systems are custom-tailored for a single use case and do not allow for any flexibility as they must be configured statically at boot time.


In this dissertation, we address the three following research questions concerning the trusted path and trusted execution in mode rn platforms 
\begin{enumerate}
    \item[\textbf{Q1}] Why existing solutions failed to provide a trusted path that provides integrity and confidentiality guarantees to the user interactions? What are the necessary steps in order to build one?
    
    \item[\textbf{Q2}] Relay attack from a local platform to a remote attacker-controlled platform is a real threat on the remote attestation of TEEs like Intel SGX. How to ensure that the attacker is not able to relay the attestation to an attacker-controlled platform that exposes all the sensitive IO data?
    
    \item[\textbf{Q3}] How to extend the trusted path mechanism to a modern platform that is interconnected with a number of heterogeneous peripheral devices? How to make sure the platform-wide integrity guarantee (configuration and interaction of the TEE enclaves and external peripherals) is preserved without relying on a purpose-built system?  
\end{enumerate}


The shortcomings of the existing literature provide the groundwork of our system named \protection that answers the first research question \textbf{Q1}.
\protection is built on the following observations: i) input integrity is possible only when both input and output integrity are ensured simultaneously, ii) all the input modalities are needed to be protected as they influence each other, and iii) high cognitive load results in user habituation errors. \protection uses a trusted low-TCB auxiliary device that we call \deviceprotection, which works as a mediator between all user IO devices and the untrusted host. Instead of implementing a separate network interface, the \deviceprotection uses the host as an untrusted transport - reducing the attack surface. \protection ensures output integrity and confidentiality by sending an encoded UI to the host that only the \deviceprotection can overlay on the part of the screen. The overlay is possible as the \deviceprotection intercepts the display signal between the host and the monitor. The overlay generated by the \deviceprotection ensures that the host cannot manipulate any output information on that overlaid part of the screen; hence, it can not trick the user. All the user interaction to this protected overlay is encrypted and signed by the \deviceprotection. Hence input integrity and confidentiality are preserved.

Parno~\cite{parno2008bootstrapping} identified distance bounding as a candidate solution to TPM relay attacks already ten years ago, but concluded that it could not be realized securely as the slow TPM identification operations (signatures) make a local and relayed attestation indistinguishable. However, the implication if the relay attack was never well-studied. In this dissertation, we investigate the implication of the relay attack and show that it could have an adverse consequence. To answer the second research question, \textbf{Q2},  We propose a new solution, called \proximitee, that prevents relay attacks by leveraging a simple embedded device that we call \deviceproximitee that is attached to the attested target platform. The \deviceproximitee executes a challenge-response protocol between itself and the platform, and based on the latency of the protocol; the \deviceproximitee determines if it is connected to the target platform physically or not. Our solution is best suited to scenarios where i) the deployment cost of such an embedded device is minor compared to the benefit of more secure attestation, and ii) TOFU solutions are not acceptable. Attestation of servers at cloud computing platforms and setup of SGX-based permissioned blockchains are two such examples. 


Finally, to answer the last question, \textbf{Q3}, we investigate systems where the TCB can be dynamically configured across multiple hardware components. We call such a system \emph{Platform Isolation Environment} or \pie.  The shift towards dynamic TCBs has wide-ranging implications concerning isolation, attestation, and integrity --- some of the typical security properties of traditional TEEs. In order not to reinvent the wheel, we rely on the many existing TEEs on the processor~\cite{costan2016intel,costan2016sanctum, keystone} and on the rather new proposals to create fully blown TEEs on peripherals~\cite{volos2018graviton,visor}, and combine them into a \pie{}. To achieve that, isolation must be expanded to the communication with other components such as other enclave or the peripherals. Similarly, attestation must span the entire platform. The attestation not only includes the individual measurements of the enclaves or peripherals, but also the communication links between them. To guarantee integrity for \pie{}, we rely on integrity properties in traditional TEEs where the enclave will halt execution upon a malicious manipulation. However, in \pie{}, the processor must be aware of the integrity of the connected peripherals as well. It needs awareness of the state of surrounding peripherals, a property we call \emph{platform awareness}. This allows an enclave on the processor to be aware of the state of connected peripherals and react upon changes in them.