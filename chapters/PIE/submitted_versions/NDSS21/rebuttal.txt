We thank the anonymous reviewers for their valuable feedback. We aggregate the issues raised in the reviews and address them below.
Insufficient Implementation/Performance Evaluation (A, B, C, D)

We fully agree with the reviewers. We have already begun to expand the performance evaluation, and we think we can reasonably add the following results in the timeframe of a major revision:

    Context switch overhead (B): We can easily perform this measurement and add the results.
    The number of PMP/enclaves (B): Increasing the number of enclaves does not affect their performance, it only affects the area overhead. Nevertheless, we can add more measurements and also measure 64 PMP entries. Besides, as soon as the hypervisor spec for RISC-V is available, PIE may be able to switch to MMU based isolation - making the number of enclaves virtually unlimited.
    Only simple peripherals (A,C,D): We are in the process of evaluating a more complex peripheral: a large accelerator based on RISC-V [1]. We plan to extend the accelerator with hardware-based multi-tenant isolation, and we also plan to measure the overhead of the firmware changes.
    **Isolation within a controller enclave (C): We plan to implement a concrete example scenario where multiple application enclaves connect to a single controller enclave to access a peripheral. The controller enclave isolates the sessions from those applications accessing the same peripheral concurrently.
    Full end-to-end implementation (C,D): Unlike keystone/SGX, a single SDK as an E2E solution is not possible for PIE due to the heterogeneity of our target platforms. Compared to Keystone, which only runs on a standard RISC-V core, our platform includes proprietary and intransparent peripherals. With this in mind, we try to emulate what we cannot control and provide an accurate estimation for real-world performance. In general, we believe that PIE can serve as a blueprint for how developers of different applications, drivers, and firmware could (minimally) modify their code in order to take advantage of platform-wide enclaves. As mentioned earlier, we will provide a concrete E2E example scenario (application enclaves, controller enclave, and peripheral). Additionally, we will add a list of minimal modifications that are required by a peripheral to enable platform-wide enclaves in that specific application scenario (e.g., adding key material).

Attacker Model and Side-channels

Attacker model (A, C, D): In the paper, we primarily consider a remote adversary contrary to the stronger local physical attacker model of traditional TEEs. We will clarify the following points in the revised version:

    First, to eliminate further confusion, we will classify peripherals into two categories, sensor-type, and non-sensor type, as they fit into two different attacker models. Sensor-type peripherals rely on the surrounding environment for data while the latter is independent of its surrounding. (Note that this classification is separate from the classification of simple and complex peripherals where the classification is solely based on the computational capability of the peripherals.)
    We will clarify why the security assumption of traditional TEE cannot be applied directly to the sensor-type peripherals. As an example, consider a light sensor: a physical adversary can manipulate the sensor reading by pointing a light source at it.
    On the other hand, non-sensor peripherals do not interact with their physical environment (e.g., GPU, storage, etc.), and they can tolerate local physical attackers. Incorporating well-established measures such as memory and bus encryption can ensure both integrity and confidentiality against a local physical attacker. Note that such mechanisms might not be trivial and there are several aspects that we plan to discuss (such as a replay attack on DMA). As an example, these measures will add some overhead, e.g., the memory encryption has measurable overhead in Intel SGX. 

Side-channel attacks (D, E): We agree with the reviewers that side-channel attacks have become a serious threat to TEEs. Therefore, we will add a discussion about various side-channel protection measures and how to apply them to our architecture. We want to focus specifically on the changes that we have introduced and their accompanying side-channels.
Novelty/Motivation (A,B,C)

It may seem like PIE is similar to a strawman solution where the privileged software in the TCB, and thus the security properties are extended to the platform as a whole from the CPU. Just aggregating everything (firmware, driver, and application) into a static TCB, similar to SGXIO, is not a solution in the context of modern platforms that require a dynamic (hardware) TCB. E.g., the keyboard on a PC is accessed by multiple applications at the same time even though keystrokes may be sensitive. Moreover, peripherals may be disconnected, or they may be exclusively claimed by a single application for a certain time span (e.g., when the user is typing her credentials, the OS should not be able to see the keystrokes).

In the presence of fully blown TEEs on peripherals, there may indeed be other solutions (A). However, while these systems provide excellent properties, they also pose challenges that are not trivially addressable, such as how to synchronize a peripheral’s enclave and an enclave on the CPU. For instance, naively encrypting the channel between them raises functional concerns as it is unclear how DMA would work on encrypted data with integrity requirements (e.g., what considerations need to be made to prevent replay attacks?). Besides, we note that PIE also works with simple peripherals that do not support fully-fledged TEEs. Moreover, PIE is able to achieve similar security properties without relying on the encryption capabilities of peripherals (which may be expensive).
Peripherals and Firmware

We will clarify the role of firmware in the next version. We will also add an explicit example of firmware modifications to support PIE. We also point out that the firmware and the driver themselves could, of course, be optimized for a small TCB. However, if a certain peripheral must be used, one cannot get around trusting at least a minimal driver and the firmware on the peripheral. Note, however, that in contrast to traditional system architectures, in PIE there is only one driver in the TCB: the driver of the desired peripheral.
Minor

    We will improve the comparison with related work such as SGXIO and non-PMP-based TEEs (B).
    “Comparison to previous dynamic RA schemes is missing” (D): We will add a proper discussion to similar proposals in the field of RA.
    Remote attestation of the peripherals (C): Unlike the standard remote attestation provided by KeyStone/SGX (through code measurement and signing), in PIE, we only assume that the manufacturer ships the peripherals with key material in tamper-resilient storage. This allows the processor core-enclaves to verify the legitimacy of the peripheral.
    End-users to verify (E): This is always the case for remote attestation for TEEs such as SGX and Keystone. Otherwise, the malicious OS could simulate an enclave.
    Trusted boot vs. remote attestation (E): Trusted boot has been used extensively in the past, but it usually fails in keeping the TCB small. We note that other proposals, such as dynamic-root-of-trust, could also be extended to full platforms while keeping the TCB minimal.

[1]: Florian Zaruba et al. “Manticore: A 4096-core RISC-V Chiplet Architecture for Ultra-efficient Floating-point Computing”, HotChips 2020
