\section{Introduction}
\label{sec: intro}


Till now, in this dissertation, in \protection~\ref{ch:protectIOn}, we have seen the fundamental properties that are required by an application to implement a trusted path while using an external trusted device as an intermediary. In \proximitee~\ref{ch:proximitee}, we  discuss how this external intermediary can perform a distance-bound protocol to ensure that the peripherals are communicating with a specific platform in a scenario where the trusted path application is an Intel SGX enclave. All this works, including the previously discussed ad-hoc approaches like \integrikey and \integriscreen uses external trusted device to facilitate a trusted path between the peripheral device and the application. In all of these works, we assume a traditional CPU-centric model where the remote services are executed primarily in the CPU (or an enclave running on the CPU cores) on the trusted endpoint and traditional user-facing components such as IO devices.

\subsection{Disaggregated Computation}

Recently we have seen a seismic shift to the traditional CPU-centric computation model. Complex devices such as GPU, network card, accelerators etc are common in the data-centers as well as consumer-centric platforms. Unlike IO peripherals, these complex devices, that we call \sphw, has compute capability. For example, GPUs provide much higher performance in tasks such as machine learning over a large data set, scientific simulations. Data center applications that requires large bandwidth often uses kernel transport layer security (kTLS) to offload cryptographic operations from the CPU to the NIC, thus saving crucial CPU cycles. In these modern platform architectures, effectively CPU's main role is shifted towards a coordinator role, i.e., setting up the computation for certain workloads~\cite{spec_hw_acc} in the relevant \sphw and then collecting the results, possibly to feed them to yet another \sphw. Cloud computing architectures are even adopting a \emph{disaggregated} model called \emph{composable disaggregated infrastructure}~\cite{disaggregatedcomp,fungible,meyer2017disaggregated,lim2009disaggregated} in which data centers no longer just consist of a number of connected servers, but of functional blocks connected with high-speed interconnects. Each block provides a pool of a particular resource, be it GPUs, CPUs, storage, FPGAs, to allow for fine-grained resource allocation and acceleration. When more resources are requested, only a particular block needs to be augmented, rather than requiring the provisioning of full-fledged monolithic servers. Moreover, unlike the trusted intermediary connected to the platform over the USB interface, these \sphw devices can connect over interfaces such as PCI-express and having an external intermediary is not feasible in such high-speed interfaces. 


At the same time, the security of modern systems has also come under scrutiny due to the numerous vulnerabilities related to the high complexity of operating systems and hypervisors~\cite{checkoway2013iago,suzaki2011memory}.
Because of this, it has become more attractive to rely on smaller and lower layers, i.e., firmware or even immutable hardware to enforce security and to reduce the underlying trusted computing base (TCB).
Most notably, this has led to the rise in trusted execution environments (TEEs). 
TEE designs vary to a large degree but, in general, they isolate execution environments without having to trust operating systems and hypervisors~\cite{costan2016intel,winter2008trusted,costan2016sanctum}. TEEs rely on hardware primitives of the CPU and only consider the CPU package to be trusted, while all the other hardware components of the platform are explicitly assumed malicious. 

% Looking at the paths that \sphw, disaggregated computing, and TEE efforts are paving, it is not hard to notice that the improvements in computing power and scalability do not bode well with the ones in security. 
These two developments present an apparent disconnect: on one side, modern computer architectures are increasingly relying on \sphw for performance and scalability. On the other, TEEs provide strong security guarantees only if code and data are confined within the CPU.
Using \sphw in existing TEEs either requires to trust the OS (e.g., SGX~\cite{costan2016intel}) or to bloat hypervisors or specialized OS (TrustZone Secure OS~\cite{TZOS}) with drivers. E.g., the keyboard input to an SGX enclave can be read and altered by the untrusted OS, whereas in the case of TrustZone, the security of that input depends on the large TCB, including drivers for unused peripherals. Since the \emph{hardware} TCB of a TEE is statically decided at design time by the CPU manufacturer, end-users need to rely not only on a fixed hardware TCB, but also potentially need to add drivers of other devices into the software TCB if other enclaves want to make use of them. In other words, current TEEs struggle to support \sphw while adhering to the principle of least privilege.


\subsection{Our Proposal}

We propose a TEE with a \emph{configurable} software and hardware TCB including arbitrary \sphw, a concept that we name \emph{platform isolation environment} (\name). \name executes applications in \emph{platform-wide enclaves}, which are analogous to the enclaves provided by TEEs, except that they span several hardware components. For example, a \nameenclave{} can be composed of a GPU (or only some GPU cores) and the CPU, and the custom code running on them. Like in traditional enclaves, a \nameenclave{} can be remotely attested. However, the \name attestation not only reports a measurement of the software TCB but also of the hardware components that are part of the \nameenclave{}.

The shift towards configurable hardware and software TCBs has wide-ranging implications concerning integrity, confidentiality, and attestation of a \nameenclave{}. 
Attestation, for one, should cover all individual components of a \nameenclave{} atomically to defend against an attacker that changes the configuration in between attestations to separate components. 
Moreover, the untrusted OS may remap \sphw devices at runtime with an untrustworthy device, which should not receive access to sensitive data. We carefully design \name{} to not be vulnerable to such attacks and present an in-depth security analysis.
% Lastly, it is essential to maintain compatibility with the existing ecosystem of device drivers and applications.

We mitigate the above-mentioned attacks with two new properties of \nameenclave{}s: \emph{platform-wide attestation} and \emph{platform awareness}. Platform-wide attestation expands the attestation to cover all components within a \nameenclave, and platform awareness enables enclaves to react to changes in their ecosystem, i.e., remapping by the OS.
We achieve this by introducing two new events into the enclave lifecycle, \textit{connect} and \textit{disconnect}, which allow to track the liveliness of one enclave from another.

We validate the challenges and design choices in a prototype that we develop on top of RISC-V and Keystone~\cite{keystone}. We make the key design decision to facilitate the communication between \sphw and the CPU with shared memory. This not only reduces the cost of context switches in enclave-to-enclave communication but also allows enclaves to communicate directly with \sphw, as these are memory-mapped, and allows to reuse existing drivers. In particular, our prototype modifies the way Keystone uses the RISC-V physical memory protections (PMP) to let enclave memory overlap, which enables shared memory. 
% Albeit we propose relatively small changes to the core implementation of Keystone, they have wide-ranging consequences for the properties the system provides and for its security. 
We perform an extensive security analysis of our prototype, analyzing the implications of our design with respect to side channels, the enclave's interactions with peripherals and their life-cycles, and how attestation can now be extended to reflect the configuration of a platform and thus form a dynamic hardware TCB. 


We further evaluate \name{} in two case studies: first, we demonstrate an end-to-end prototype on an FPGA with simple peripherals emulated on a microcontroller; and second, we take an existing accelerator~\cite{zaruba2020manticore} and integrate it into \name{}, adding support for multi-tenant isolation. In the first case study, we developed a prototype on top of an FPGA that is running a RISC-V core with keystone. The FPGA is connected to an Arduino microcontroller that emulates IO peripherals and sensors. It required around 2.5 KLoC combined for the driver and the firmware changes to enable remote attestation. 
While the first case study focuses on IO peripherals and sensors that often requires exclusive access by an application, in the second case study, we demonstrate how to adapt an existing accelerator~\cite{zaruba2020manticore} so it can support multi-tenant isolation and remote attestation. Here we enable multiple \name{}s to concurrently use the accelerator  while still giving meaningful isolation guarantees to remote verifiers. The TCB of Keystone increased by around $600$ lines of code (LoC) and the additional logic in the context switch increased by 220 cycles (from around 4700 to 4900 cycles). 
%We extended the accelerator with multi-tenant isolation and attestation in around two engineering weeks with a 10\% frequency loss due to the additional logic in the critical path.

\subsection{Our Contributiuons}

In summary, the contributions of this chapter are the following:

\begin{enumerate}
  \item \emph{New security properties} We extend traditional TEEs with a dynamic hardware TCB, i.e., the enclave's TCB only includes the driver, and firmware of the used \sphw. We call these new systems platform isolation environment (\name{}). We identify key security properties for \name{}, namely \emph{platform-wide attestation}, and \emph{platform awareness}. Additionally, we propose a software design for \name that abstracts the underlying hardware layer, and try to integrate with the existing driver ecosystem. 
  
  \item \emph{Security analysis} We analyze the security aspects of \name in detail. This includes the security implications of \name{}'s design decisions and a number of relevant side channels.
  
  \item \emph{Two case studies} We demonstrate two case studies: first, we present an end-to-end prototype based on Keystone~\cite{keystone} on an FPGA running a RISC-V processor~\cite{ariane} including multiple external peripherals emulated by Arduino microcontrollers. Our modifications to the software TCB of Keystone only amount to around 600 LoC. Second, to extend the scope of \name from IO peripherals to complex devices, we perform a case study based on a GPU-style accelerator~\cite{zaruba2020manticore} and integrate it within \name{} while also enabling multi-tenant isolation.

\end{enumerate}


\subsection{Organization of this Chapter}

The rest of the chapter is organized as the following: Section~\ref{pie:sec:problemStatement} provides the problem statement, system and the attacker model. Section~\ref{sec:overview} proves an overview of our approach. Section~\ref{sec:approach} and~\ref{sec:programmingModel} present the main idea and the programming model of \name respectively. Section~\ref{pie:sec:localAttacker} provides an proposal of modifying \name to support local physical attacker. Section~\ref{sec:eval} and~\ref{sec:securityAnalysis} describe the security analysis of \name, and  the \name prototype \& its performance respectively. Finally, Section~\ref{sec:relatedWork} and~\ref{sec:conclusion} describes the related research works and conclude this chapter respectively. 