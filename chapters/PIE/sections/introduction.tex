\section{Introduction}
\label{sec: intro}

For most of computer history, designing a computer architecture around the CPU allowed extracting the most performance benefits from Moore's law.  %However, the architecture as not caught up and data gets moved to the CPU without the need to be processed, but just to be copied to a different memory address, or just to be moved to a different peripheral. Given the increase in memory processing speed these superfluous data movements only decrease processing time (by consuming CPU cycles) and power through unnecessary data movement.
Nowadays, however, the demand for increased computation power is usually satisfied with special-purpose hardware: GPUs are orders of magnitude more efficient than a CPU can be at handling parallel workloads such as graphics and machine learning, and FPGAs often achieve similar gains for custom workloads. Tasks such as machine learning are even pervasive enough to justify the investment into fully custom ASICs~\cite{TPU}. % leading to a redesign of modern platforms.
In these modern platform architectures, the CPU's main job is to set up the computation for certain workloads~\cite{spec_hw_acc} in the relevant \sphw and then collecting the results, possibly to feed them to yet another \sphw. Effectively, the CPU's primary role is shifting towards a mere coordinator of the available \sphw in the platform.
Cloud computing architectures are even adopting a \emph{disaggregated} model~\cite{disaggregatedcomp} in which data centers no longer just consist of a number of connected servers, but of functional blocks connected with high-speed interconnects. Each block provides a pool of a particular resource, be it GPUs, CPUs, storage, FPGAs, to allow for fine-grained resource allocation and acceleration. When more resources are requested, only a particular block needs to be augmented, rather than requiring the provisioning of full-fledged monolithic servers.


% Analogously, the hardware and software upon which we base the security of computers - the trusted computing base (TCB) - has also been evolving, only it to stay on pace with adversaries. 

At the same time, the security of modern systems has also come under scrutiny due to the numerous vulnerabilities related to the high complexity of operating systems and hypervisors~\cite{checkoway2013iago,suzaki2011memory}.
Because of this, it has become more attractive to rely on smaller and lower layers, i.e., firmware or even immutable hardware to enforce security and to reduce the underlying trusted computing base (TCB).
Most notably, this has led to the rise in trusted execution environments (TEEs). 
TEE designs vary to a large degree but, in general, they isolate execution environments without having to trust operating systems and hypervisors~\cite{costan2016intel,winter2008trusted,costan2016sanctum}. TEEs rely on hardware primitives of the CPU and only consider the CPU package to be trusted, while all the other hardware components of the platform are explicitly assumed malicious. 

% Looking at the paths that \sphw, disaggregated computing, and TEE efforts are paving, it is not hard to notice that the improvements in computing power and scalability do not bode well with the ones in security. 
These two developments present an apparent disconnect: on one side, modern computer architectures are increasingly relying on \sphw for performance and scalability. On the other, TEEs provide strong security guarantees only if code and data are confined within the CPU.
Using \sphw in existing TEEs either requires to trust the OS (e.g., SGX~\cite{costan2016intel}) or to bloat hypervisors or specialized OS (TrustZone Secure OS~\cite{TZOS}) with drivers. E.g., the keyboard input to an SGX enclave can be read and altered by the untrusted OS, whereas in the case of TrustZone, the security of that input depends on the large TCB, including drivers for unused peripherals. Since the \emph{hardware} TCB of a TEE is statically decided at design time by the CPU manufacturer, end-users need to rely not only on a fixed hardware TCB, but also potentially need to add drivers of other devices into the software TCB if other enclaves want to make use of them. In other words, current TEEs struggle to support \sphw while adhering to the principle of least privilege.

We propose a TEE with a \emph{configurable} software and hardware TCB including arbitrary \sphw, a concept that we name \emph{platform isolation environment} (\name). \name executes applications in \emph{platform-wide enclaves}, which are analogous to the enclaves provided by TEEs, except that they span several hardware components. For example, a \nameenclave{} can be composed of a GPU (or only some GPU cores) and the CPU, and the custom code running on them. Like in traditional enclaves, a \nameenclave{} can be remotely attested. However, the \name attestation not only reports a measurement of the software TCB but also of the hardware components that are part of the \nameenclave{}.

The shift towards configurable hardware and software TCBs has wide-ranging implications concerning integrity, confidentiality, and attestation of a \nameenclave{}. 
Attestation, for one, should cover all individual components of a \nameenclave{} atomically to defend against an attacker that changes the configuration in between attestations to separate components. 
Moreover, the untrusted OS may remap \sphw devices at runtime with an untrustworthy device, which should not receive access to sensitive data. We carefully design \name{} to not be vulnerable to such attacks and present an in-depth security analysis.
% Lastly, it is essential to maintain compatibility with the existing ecosystem of device drivers and applications.

We mitigate the above-mentioned attacks with two new properties of \nameenclave{}s: \emph{platform-wide attestation} and \emph{platform awareness}. Platform-wide attestation expands the attestation to cover all components within a \nameenclave, and platform awareness enables enclaves to react to changes in their ecosystem, i.e., remapping by the OS.
We achieve this by introducing two new events into the enclave lifecycle, \textit{connect} and \textit{disconnect}, which allow to track the liveliness of one enclave from another.

We validate the challenges and design choices in a prototype that we develop on top of RISC-V and Keystone~\cite{keystone}. We make the key design decision to facilitate the communication between \sphw and the CPU with shared memory. This not only reduces the cost of context switches in enclave-to-enclave communication but also allows enclaves to communicate directly with \sphw, as these are memory-mapped, and allows to reuse existing drivers. In particular, our prototype modifies the way Keystone uses the RISC-V physical memory protections (PMP) to let enclave memory overlap, which enables shared memory. 
% Albeit we propose relatively small changes to the core implementation of Keystone, they have wide-ranging consequences for the properties the system provides and for its security. 
We perform an extensive security analysis of our prototype, analyzing the implications of our design with respect to side channels, the enclave's interactions with peripherals and their life-cycles, and how attestation can now be extended to reflect the configuration of a platform and thus form a dynamic hardware TCB. %% Should a teaser be here on what we actually discuss there?
% With respect to side-channels, we find that \name can be reduced to a traditional TEE, while the dynamic hardware TCB emerges via a combination of several linked traditional attestations.


%First, to provide integrity and confidentiality, we need to secure the communication between the enclaves on the CPU and the \sphw units. 
% In \name, isolation needs not only to be provided against the OS but also against all the other \sphw and their drivers. To this end, we leverage the main observation that \sphw communicates over mapped memory regions and use a shared memory primitive for all communication. Shared memory allows to re-use current drivers and enables more performant enclave to enclave communication~\cite{yu2020elasticlave}. 
%To allow for the TCB to be dynamic, the communication configuration needs to be able to change a runtime (e.g., when a new \sphw unit is desired).
% Moreover, \sphw such as GPUs support multi-tenancy -- multiple CPU enclaves running processes on the \sphw concurrently. 
%Second, \emph{remote attestation} needs to cover the entire \nameenclave{}: A remote verifier should be able to verify the communication setup within a \nameenclave, something that is not usually considered on a classical TEE attestation where the hardware TCB is static.

%% This might be reintroduced..
%Third, given the dynamic nature of the hardware components of a \nameenclave{}, it needs to be able to detect state changes within itself, a property we call \emph{platform awareness}. For instance, the enclaves on the CPU cores need to know when a \sphw is detached or reattached, as a different \sphw should not be automatically trusted by a \nameenclave{} just because they are connected to the same port or the same memory addresses as a previously trusted one.

We further evaluate \name in two case studies: first, we demonstrate an end-to-end prototype on an FPGA with simple peripherals emulated on a microcontroller; and second, we take an existing accelerator~\cite{zaruba2020manticore}, and integrate it to \name{}, adding support for multi-tenant isolation. In the first case study, we developed a prototype on top of an FPGA. The TCB of Keystone increased by around $600$ lines of code (LoC) and the additional logic in the context switch increased by 200 cycles (from around 4700 to 4900 cycles).
In our implementation, to provide more flexibility, we confine drivers in what we call \emph{controller enclaves}. This allows multiple \nameenclave{}s to use the same \sphw concurrently and enforce access control to the peripheral, e.g., rate-limiting or granting exclusive access, while still giving meaningful isolation guarantees to remote verifiers. In the second case study, we demonstrate how to adapt an existing accelerator~\cite{zaruba2020manticore} so it can support multi-tenant isolation and remote attestation in \name{}.
%We extended the accelerator with multi-tenant isolation and attestation in around two engineering weeks with a 10\% frequency loss due to the additional logic in the critical path.

% \todo{The following needs to be more clear and detailed}
% We present a prototype implementation of a \name{} based on Keystone~\cite{keystone} running on a RISC-V core~\cite{ariane} connected to peripherals that are emulated on a microcontroller.
% To create a secure channel between a CPU enclave and a \sphw enclave, we leverage the main observation that \sphw generally communicate over mapped address regions. This, in combination with the physical memory protection (PMP) from the RISC-V standard allows us to isolate the bridge the link between the various platform TEEs with a minimal TCB, while keeping the \nameenclave{} configuration dynamic.
% As opposed to Keystone in which PMPs where used only with non-overlapping memory regions, we reconfigure the SM to allow also shared memory regions. In total, this required to extend the TCB of Keystone by around 600 lines of code (LoC). Using shared memory among enclaves allow to build \nameenclave{} that do not need to rely on the OS to communicate with each other, thus not only reducing the TCB but also avoiding costly context switches.\todo{Add some numbers here}.
% To prevent drivers from bloating the TCB, we confine them in what we call \emph{controller enclaves}. These enclaves share memory with \sphw through DMA or memory mapped IO (MMIO), and enforce the access control to the peripheral. This allows to enforce and attest exclusive access to certain \sphw if required by an application all the while requiring very small changes to the actual drivers to be integrated in \name.


% On top of that, we propose a programming model that allows the same flexibility as previous systems for peripherals, where multiple applications interact with them simultaneously. We engineer this system as a set of intended and mutually attested enclaves. In particular, we propose three distinct enclaves, an application enclave, a controller enclave, and a peripheral enclave. Each enclave is completely isolated from everything else, and by default, in the spirit of TEEs, only needs to trust the hardware on which it is running. 



In summary, the contributions of our paper are the following:

\begin{enumerate}
  \item We extend traditional TEEs with a dynamic hardware TCB, i.e., the enclave's TCB only includes the driver, and firmware of the used \sphw. We call these new systems platform isolation environment (\name{}). We identify key security properties for \name{}, namely \emph{platform-wide attestation}, and \emph{platform awareness}. Additionally, we propose a software design for \name that abstracts the underlying hardware layer, and try to integrate with the existing driver ecosystem. 
  
  \item We analyze the security aspects of \name in detail. This includes the security implications of \name{}'s design decisions and a number of relevant side channels.
  
  \item We demonstrate two case studies: first, we present an end-to-end prototype based on Keystone~\cite{keystone} on an FPGA running a RISC-V processor~\cite{ariane} including multiple external peripherals emulated by Arduino microcontrollers. Our modifications to the software TCB of Keystone only amount to around 600 LoC. Second, we perform a case study based on a GPU-style accelerator~\cite{zaruba2020manticore} and integrate it within \name{} while also enabling multi-tenant isolation.

\end{enumerate}

% The rest of the paper is organized as the following: Section~\ref{sec:background} gives a brief background that our work is based on. Section~\ref{sec:problemStatement} provides the problem statement, system and the attacker model. Section~\ref{sec:approach} and~\ref{sec:programmingModel} present the main idea and the programming model of \name respectively. Section~\ref{sec:eval} and~\ref{sec:securityAnalysis} describe the \name prototype \& its performance and the security analysis of \name. Finally, Section~\ref{sec:relatedWork} and~\ref{sec:conclusion} describes the related research works and conclude the paper respectively. 